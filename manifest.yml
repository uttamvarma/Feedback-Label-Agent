app:
  id: ari:cloud:ecosystem::app/d09ed9df-fde2-432a-aa75-945beca1609b
  runtime:
    name: nodejs22.x


modules:
  rovo:agent:
    - key: feedback-labeller-agent
      name: "Feedback Labeller"
      description: "Classifies customer feedback rows on the current Confluence page into Theme & Impact and writes results back to the table."
      prompt: |
        You are an Atlassian Rovo Agent that labels customer feedback in a Confluence table.
        STRICT TAXONOMY:
          THEME must be one of: "Feature Request", "Integration", "Bug", "Query", "Other".
          IMPACT must be one of: "High", "Medium", "Low".
        Capitalization is not important in the source data.

        CONTEXT: You will be invoked from a Confluence page. Use the page context to operate on that page only. Do not ask for IDs.

        WORKFLOW:
        1) Invoke action "get-next-rows" with batchSize=20 (or a smaller number if fewer rows remain). It returns the first feedback table, column indexes, and up to 20 rows where THEME or IMPACT is currently empty. Each row includes rowIndex (0-based, header excluded), subject, description.
        2) For each row, read subject and description and decide THEME and IMPACT using STRICT TAXONOMY. If you are uncertain, choose the closest category; prefer "Other" only when no category fits.
        3) Invoke action "apply-labels" with a JSON string `labels` containing an array of objects: { rowIndex, theme, impact } where `theme` and `impact` exactly match the STRICT TAXONOMY strings above.
        4) If there are still empty rows remaining, repeat until all are labeled. Keep responses concise; report count updated.

        QUALITY:
        - Be deterministic and consistent. Use patterns: requests for new functionality → Feature Request; external system/API/app mentions → Integration; defects/errors → Bug; how‑to or information requests → Query; else → Other. Impact reflects customer urgency/business risk: critical blockers/data loss/security → High; meaningful but not blocking → Medium; minor or cosmetic → Low.

      conversationStarters:
        - "Label the next 20 feedback rows on this page"
        - "Re-scan this page for any unlabeled feedback and label them"
      actions:
        - get-next-rows
        - apply-labels

  action:
    - key: get-next-rows
      name: "Get next unlabeled feedback rows"
      function: getNextRows
      actionVerb: GET
      description: "Returns up to N (default 20) unlabeled rows (Theme/Impact empty) from the first feedback table on the current Confluence page."
      inputs:
        batchSize:
          title: "Batch size"
          type: integer
          required: false
          description: "How many rows to fetch (max 20)."

    - key: apply-labels
      name: "Apply Theme/Impact labels"
      function: applyLabels
      actionVerb: UPDATE
      description: "Writes LLM-chosen Theme & Impact values back into the feedback table for the specified row indexes."
      inputs:
        labels:
          title: "Row labels payload (JSON string)"
          type: string
          required: true
          description: "JSON string of array items: { rowIndex, theme, impact } with exact taxonomy values."

  confluence:contentBylineItem:
    - key: feedback-labeller-byline
      title: "Label next 20 rows"
      function: bylineResolver

  function:
    - key: getNextRows
      handler: index.getNextRows
    - key: applyLabels
      handler: index.applyLabels
    - key: bylineResolver
      handler: index.bylineDynamic


permissions:
  scopes:
    - read:page:confluence     # REST v2 GET page with body-format=storage
    - write:page:confluence    # REST v2 PUT page storage body
    - read:chat:rovo           # expose actions to Rovo chat / customer agents
    - storage:app              # structured critical-failure logs